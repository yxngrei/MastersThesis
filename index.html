<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>p5.js + Tone.js + PapaParse CSV Chords</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      color: #fff;
      font-family: sans-serif;
    }
    canvas { display: block; }
    #fileInput {
      position: absolute;
      top: 10px;
      left: 180px;
      z-index: 10;
      padding: 5px;
      background: #333;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
    }
  </style>
</head>
<body>

<input type="file" id="fileInput" accept=".csv" />

<script>
let chordBlocks = [];
let paletteBlocks = [];
let allChordSuggestions = [];
let currentPage = 0;
let chordsPerPage = 8;
let draggingBlock = null;
let resizingBlock = null;
let resizingSide = null;
let offsetX = 0, offsetY = 0;
let isDraggingPalette = false;

const gridStartX = 240;
const gridSpacing = 80;
const snapStep = 40;
const timelineY = 80;
const minGridUnits = 1;
const resizeMargin = 10;

let isPlaying = false;
let sortedChordBlocks = [];
let highlightedBlock = null;
let lastHighlightedBlock = null;
let currentPlayIndex = -1; // For highlighting active chord during Transport playback

const synth = new Tone.PolySynth(Tone.Synth).toDestination();

function setup() {
  createCanvas(1920, 1080);

  chordBlocks.push(new ChordBlock(gridStartX, timelineY, "C", "I", color(100, 150, 255), 2, ["C4", "E4", "G4"]));
  chordBlocks.push(new ChordBlock(gridStartX + 160, timelineY, "Am", "vi", color(255, 100, 150), 1, ["A4", "C5", "E5"]));

  document.getElementById("fileInput").addEventListener("change", function(evt) {
    let file = evt.target.files[0];
    if (!file) return;
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      dynamicTyping: false,
      complete: function(results) {
        allChordSuggestions = [];
        buildChordSuggestionsFromCSV(results.data);
        currentPage = 0;
        updatePaletteDisplay();
      }
    });
  });

  allChordSuggestions.push(
    { chord: "G", numeral: "V", color: color(255, 200, 100), notes: ["G4", "B4", "D5"] },
    { chord: "Dm", numeral: "ii", color: color(200, 100, 255), notes: ["D4", "F4", "A4"] },
    { chord: "Em", numeral: "iii", color: color(100, 255, 200), notes: ["E4", "G4", "B4"] },
    { chord: "F", numeral: "IV", color: color(255, 150, 100), notes: ["F4", "A4", "C5"] },
    { chord: "Am7", numeral: "vi7", color: color(150, 255, 150), notes: ["A4", "C5", "E5", "G5"] },
    { chord: "Bb", numeral: "♭VII", color: color(255, 100, 255), notes: ["Bb4", "D5", "F5"] },
    { chord: "Cm", numeral: "i", color: color(100, 200, 255), notes: ["C4", "Eb4", "G4"] },
    { chord: "D7", numeral: "V7/V", color: color(255, 255, 100), notes: ["D4", "F#4", "A4", "C5"] },
    { chord: "Gm", numeral: "v", color: color(200, 150, 255), notes: ["G4", "Bb4", "D5"] }
  );
  updatePaletteDisplay();
}

function buildChordSuggestionsFromCSV(data) {
  for (let row of data) {
    let chordName = row['Chords']?.trim() || row['Chord']?.trim() || row['chord']?.trim() || row['CHORDS']?.trim();
    let notesString = row['Notes_From_Degrees'] || row['Notes_from_Degrees'] || row['notes_from_degrees'] || row['Notes'] || row['notes'];
    if (!chordName || !notesString) continue;
    let notesArray = parseNotes(notesString);
    if (notesArray.length === 0) continue;
    let chordColor = color(random(80, 255), random(80, 255), random(80, 255));
    allChordSuggestions.push({ chord: chordName, numeral: "", color: chordColor, notes: notesArray });
  }
}

function updatePaletteDisplay() {
  paletteBlocks = [];
  let startIndex = currentPage * chordsPerPage;
  let endIndex = min(startIndex + chordsPerPage, allChordSuggestions.length);
  for (let i = startIndex; i < endIndex; i++) {
    let cd = allChordSuggestions[i];
    let x = 80 + ((i - startIndex) * 160);
    let y = 520;
    paletteBlocks.push(new ChordBlock(x, y, cd.chord, cd.numeral, cd.color, 1, cd.notes));
  }
}

function parseNotes(notesStr) {
  if (!notesStr) return [];
  let cleanStr = String(notesStr).trim();
  let notes = [];
  if (cleanStr.includes(',')) notes = cleanStr.split(',');
  else if (cleanStr.includes(' ')) notes = cleanStr.split(' ');
  else if (cleanStr.includes(';')) notes = cleanStr.split(';');
  else if (cleanStr.length > 0) notes = [cleanStr];
  return notes.map(n => n.replace(/[\[\]"']/g, '').trim())
              .filter(n => /[A-Ga-g][#b]?[0-9]/.test(n));
}

function draw() {
  background(20);
  checkHighlightedChord();
  drawUI();
}

function checkHighlightedChord() {
  highlightedBlock = null;
  if (!draggingBlock && !resizingBlock) {
    for (let block of chordBlocks) {
      if (block.isMouseInside()) { highlightedBlock = block; break; }
    }
    if (!highlightedBlock) {
      for (let block of paletteBlocks) {
        if (block.isMouseInside()) { highlightedBlock = block; break; }
      }
    }
  }
  if (highlightedBlock && highlightedBlock !== lastHighlightedBlock) {
    if (highlightedBlock.notes?.length) {
      if (Tone.context.state !== 'running') Tone.start();
      synth.triggerAttackRelease(highlightedBlock.notes, "8n");
    }
  }
  lastHighlightedBlock = highlightedBlock;
}

function drawUI() {
  fill(40); noStroke(); rect(0, 0, width, 50);
  fill(255); textSize(16); textAlign(LEFT, BASELINE); text("Verse", 20, 35);
  drawPlayButton(100, 15, 60, 25);

  fill(60); rect(20, 60, width - 40, 80);
  fill(255); textSize(14); textAlign(CENTER, CENTER); text("Chord Progression", 120, 75);
  drawTimeline(gridStartX, 60, 32);

  for (let i = 0; i < chordBlocks.length; i++) {
    const block = chordBlocks[i];
    const isActive = isPlaying && i === currentPlayIndex;
    const isHighlighted = highlightedBlock === block;
    block.display(isActive, isHighlighted);
  }

  fill(30); rect(0, 450, width, 200);
  fill(200); textSize(18); textAlign(LEFT, BASELINE); text("Chord Suggestions", 20, 475);
  if (allChordSuggestions.length) {
    let totalPages = Math.ceil(allChordSuggestions.length / chordsPerPage);
    fill(150, 200, 150); textSize(12);
    text(`Page ${currentPage + 1} of ${totalPages} (${allChordSuggestions.length} total chords)`, 20, 495);
    drawPaginationButtons(20, 500, totalPages);
  }
  for (let block of paletteBlocks) {
    const isHighlighted = highlightedBlock === block;
    block.display(false, isHighlighted);
  }
  if (draggingBlock && isDraggingPalette) draggingBlock.display(false, false);
}

function drawPaginationButtons(x, y, totalPages) {
  let bw = 30, bh = 20, bs = 5;
  let prevEnabled = currentPage > 0;
  fill(prevEnabled ? 80 : 40); stroke(prevEnabled ? 150 : 80); rect(x, y, bw, bh, 3);
  fill(prevEnabled ? 255 : 100); noStroke(); textAlign(CENTER, CENTER); text("◀", x + bw/2, y + bh/2);
  let pageX = x + bw + bs;
  fill(60); stroke(120); rect(pageX, y, 80, bh, 3);
  fill(255); noStroke(); text(`${currentPage + 1} / ${totalPages}`, pageX + 40, y + bh/2);
  let nextEnabled = currentPage < totalPages - 1;
  let nextX = pageX + 80 + bs;
  fill(nextEnabled ? 80 : 40); stroke(nextEnabled ? 150 : 80); rect(nextX, y, bw, bh, 3);
  fill(nextEnabled ? 255 : 100); noStroke(); text("▶", nextX + bw/2, y + bh/2);
}

function drawPlayButton(x, y, w, h) {
  fill(isPlaying ? 60 : 80); stroke(255); rect(x, y, w, h, 5);
  fill(255); noStroke(); textSize(14); textAlign(CENTER, CENTER);
  text(isPlaying ? "Stop" : "Play", x + w/2, y + h/2);
}

function drawTimeline(startX, y, steps) {
  stroke(100);
  for (let i = 0; i < steps; i++) {
    let x = startX + i * snapStep;
    line(x, y, x, y - 10);
    noStroke(); fill(150); textAlign(CENTER, BASELINE); textSize(10);
    if (i % 2 === 0) text((i / 2 + 1), x, y - 15);
    stroke(100);
  }
}

class ChordBlock {
  constructor(x, y, chord, numeral, col, lengthInGrids = 1, notes = []) {
    this.x = x; this.y = y;
    this.w = gridSpacing * lengthInGrids;
    this.h = 50;
    this.chord = chord; this.numeral = numeral;
    this.col = col; this.notes = notes;
  }
  display(isGlowing = false, isHighlighted = false) {
    if (isHighlighted) {
      let pulse = sin(frameCount * 0.2) * 0.3 + 0.7;
      stroke(255, 200 * pulse); strokeWeight(2);
      fill(lerpColor(this.col, color(255), 0.3));
    } else if (isGlowing) {
      let glow = sin(frameCount * 0.3) * 100 + 155;
      stroke(255, glow); strokeWeight(3); fill(this.col);
    } else {
      stroke(255, 100); strokeWeight(1); fill(this.col);
    }
    rect(this.x, this.y, this.w, this.h, 8);
    if (!isGlowing && !isHighlighted) {
      fill(255, 100); noStroke();
      rect(this.x, this.y, resizeMargin, this.h, 8, 0, 0, 8);
      rect(this.x + this.w - resizeMargin, this.y, resizeMargin, this.h, 0, 8, 8, 0);
    }
    fill(255); noStroke(); textSize(16); textAlign(CENTER, CENTER);
    text(this.chord, this.x + this.w/2, this.y + this.h/2 - 5);
    if (this.numeral) { textSize(10); fill(255, 150); text(this.numeral, this.x + this.w/2, this.y + this.h/2 + 10); }
  }
  isMouseInside() { return mouseX > this.x && mouseX < this.x + this.w && mouseY > this.y && mouseY < this.y + this.h; }
  isMouseOnLeftEdge() { return mouseX > this.x && mouseX < this.x + resizeMargin && mouseY > this.y && mouseY < this.y + this.h; }
  isMouseOnRightEdge() { return mouseX > this.x + this.w - resizeMargin && mouseX < this.x + this.w && mouseY > this.y && mouseY < this.y + this.h; }
  cloneAt(x, y) { return new ChordBlock(x, y, this.chord, this.numeral, this.col, this.w / gridSpacing, [...this.notes]); }
  snapToGrid() {
    this.x = round((this.x - gridStartX) / snapStep) * snapStep + gridStartX;
    this.w = round(this.w / snapStep) * snapStep;
    this.w = max(this.w, minGridUnits * snapStep);
  }
}

function isOverlapping(a, b) { return !(a.x + a.w <= b.x || a.x >= b.x + b.w); }

function mousePressed() {
  if (mouseX > 100 && mouseX < 160 && mouseY > 15 && mouseY < 40) {
    if (!isPlaying) {
      sortedChordBlocks = chordBlocks
        .filter(b => b.y === timelineY && b.notes?.length)
        .slice().sort((a, b) => a.x - b.x);
      if (sortedChordBlocks.length > 0) {
        Tone.Transport.cancel();
        let timePos = 0;
        sortedChordBlocks.forEach((block, i) => {
          let beats = Math.max(1, block.w / snapStep);
          Tone.Transport.schedule(time => {
            currentPlayIndex = i;
            synth.triggerAttackRelease(block.notes, beats + "n", time);
          }, `${timePos}n`);
          timePos += beats;
        });
        currentPlayIndex = -1;
        Tone.start();
        Tone.Transport.start();
        isPlaying = true;
      }
    } else {
      Tone.Transport.stop();
      Tone.Transport.cancel();
      currentPlayIndex = -1;
      isPlaying = false;
    }
    return;
  }
  if (allChordSuggestions.length > 0) {
    let totalPages = Math.ceil(allChordSuggestions.length / chordsPerPage);
    let buttonY = 500, bh = 20, bw = 30, bs = 5;
    if (mouseX >= 20 && mouseX <= 20 + bw && mouseY >= buttonY && mouseY <= buttonY + bh && currentPage > 0) {
      currentPage--; updatePaletteDisplay(); return;
    }
    let nextX = 20 + bw + bs + 80 + bs;
    if (mouseX >= nextX && mouseX <= nextX + bw && mouseY >= buttonY && mouseY <= buttonY + bh && currentPage < totalPages - 1) {
      currentPage++; updatePaletteDisplay(); return;
    }
  }
  for (let block of chordBlocks) {
    if (block.isMouseOnLeftEdge()) { resizingBlock = block; resizingSide = "left"; return; }
    if (block.isMouseOnRightEdge()) { resizingBlock = block; resizingSide = "right"; return; }
  }
  for (let block of paletteBlocks) {
    if (block.isMouseInside()) {
      draggingBlock = block.cloneAt(block.x, block.y);
      isDraggingPalette = true;
      offsetX = mouseX - block.x;
      offsetY = mouseY - block.y;
      return;
    }
  }
  for (let block of chordBlocks) {
    if (block.isMouseInside()) {
      draggingBlock = block;
      isDraggingPalette = false;
      offsetX = mouseX - block.x;
      offsetY = mouseY - block.y;
      draggingBlock.originalX = block.x;
      draggingBlock.originalY = block.y;
      return;
    }
  }
}

function mouseDragged() {
  if (resizingBlock) {
    if (resizingSide === "right") {
      let newW = mouseX - resizingBlock.x;
      resizingBlock.w = max(round(newW / snapStep) * snapStep, snapStep * minGridUnits);
    } else if (resizingSide === "left") {
      let oldRight = resizingBlock.x + resizingBlock.w;
      let newX = round((mouseX - gridStartX) / snapStep) * snapStep + gridStartX;
      newX = min(newX, oldRight - snapStep * minGridUnits);
      resizingBlock.x = newX;
      resizingBlock.w = oldRight - newX;
    }
    return;
  }
  if (!draggingBlock) return;
  if (isDraggingPalette) {
    draggingBlock.x = mouseX - offsetX;
    draggingBlock.y = mouseY - offsetY;
    return;
  }
  let snappedX = round((mouseX - offsetX - gridStartX) / snapStep) * snapStep + gridStartX;
  snappedX = constrain(snappedX, gridStartX, width - draggingBlock.w);
  draggingBlock.x = snappedX;
  draggingBlock.y = timelineY;
}

function mouseReleased() {
  if (resizingBlock) {
    resizingBlock.snapToGrid(); resizingBlock = null; resizingSide = null; return;
  }
  if (!draggingBlock) return;
  draggingBlock.snapToGrid();
  let hasOverlap = chordBlocks.some(block => block !== draggingBlock && block.y === timelineY && isOverlapping(block, draggingBlock));
  if (hasOverlap) {
    if (!isDraggingPalette) {
      draggingBlock.x = draggingBlock.originalX;
      draggingBlock.y = draggingBlock.originalY;
    }
  } else {
    if (isDraggingPalette && draggingBlock.y < 450) {
      draggingBlock.y = timelineY; chordBlocks.push(draggingBlock);
    }
  }
  draggingBlock = null; isDraggingPalette = false;
}

function doubleClicked() {
  for (let i = chordBlocks.length - 1; i >= 0; i--) {
    if (chordBlocks[i].isMouseInside()) { chordBlocks.splice(i, 1); break; }
  }
}
</script>

</body>
</html>
